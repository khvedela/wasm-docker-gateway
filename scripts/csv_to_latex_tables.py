#!/usr/bin/env python3
"""
Generate compact LaTeX tabular snippets from summary CSV files.

Default inputs:
  results/summary/cold_start_percentiles.csv
  results/summary/warm_latency_percentiles.csv
  results/summary/throughput_summary.csv

Default outputs:
  results/summary/cold_start_percentiles.tex
  results/summary/warm_latency_percentiles.tex
  results/summary/throughput_summary.tex
"""

from __future__ import annotations

import argparse
import csv
import os
from dataclasses import dataclass
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP
from pathlib import Path
from typing import Callable


Formatter = Callable[[str | None], str]


@dataclass(frozen=True)
class ColumnSpec:
    key: str
    header: str
    align: str
    formatter: Formatter


@dataclass(frozen=True)
class TableSpec:
    csv_name: str
    tex_name: str
    columns: tuple[ColumnSpec, ...]


def log(msg: str) -> None:
    print(msg)


def latex_escape(value: str) -> str:
    replacements = {
        "\\": r"\textbackslash{}",
        "&": r"\&",
        "%": r"\%",
        "$": r"\$",
        "#": r"\#",
        "_": r"\_",
        "{": r"\{",
        "}": r"\}",
        "~": r"\textasciitilde{}",
        "^": r"\textasciicircum{}",
    }
    out = value
    for src, dst in replacements.items():
        out = out.replace(src, dst)
    return out


def is_missing(value: str | None) -> bool:
    if value is None:
        return True
    return value.strip() == "" or value.strip().lower() in {"na", "n/a", "nan", "none"}


def parse_decimal(value: str | None) -> Decimal | None:
    if is_missing(value):
        return None
    try:
        return Decimal(value.strip())
    except (InvalidOperation, ValueError):
        return None


def format_text(value: str | None) -> str:
    if is_missing(value):
        return "--"
    return latex_escape(value.strip())


def format_ms_1dp(value: str | None) -> str:
    dec = parse_decimal(value)
    if dec is None:
        return "--"
    rounded = dec.quantize(Decimal("0.1"), rounding=ROUND_HALF_UP)
    return f"{rounded:.1f}"


def format_int_half_up(value: str | None) -> str:
    dec = parse_decimal(value)
    if dec is None:
        return "--"
    rounded = dec.quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    return str(int(rounded))


def format_int_floorless(value: str | None) -> str:
    dec = parse_decimal(value)
    if dec is None:
        return "--"
    rounded = dec.quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    return str(int(rounded))


TABLES: tuple[TableSpec, ...] = (
    TableSpec(
        csv_name="cold_start_percentiles.csv",
        tex_name="cold_start_percentiles.tex",
        columns=(
            ColumnSpec("variant", "variant", "l", format_text),
            ColumnSpec("p50_ms", "p50 (ms)", "r", format_ms_1dp),
            ColumnSpec("p90_ms", "p90 (ms)", "r", format_ms_1dp),
            ColumnSpec("p99_ms", "p99 (ms)", "r", format_ms_1dp),
        ),
    ),
    TableSpec(
        csv_name="warm_latency_percentiles.csv",
        tex_name="warm_latency_percentiles.tex",
        columns=(
            ColumnSpec("variant", "variant", "l", format_text),
            ColumnSpec("workload", "workload", "l", format_text),
            ColumnSpec("p50_ms", "p50 (ms)", "r", format_ms_1dp),
            ColumnSpec("p90_ms", "p90 (ms)", "r", format_ms_1dp),
            ColumnSpec("p99_ms", "p99 (ms)", "r", format_ms_1dp),
        ),
    ),
    TableSpec(
        csv_name="throughput_summary.csv",
        tex_name="throughput_summary.tex",
        columns=(
            ColumnSpec("variant", "variant", "l", format_text),
            ColumnSpec("workload", "workload", "l", format_text),
            ColumnSpec("conns", "conns", "r", format_int_floorless),
            ColumnSpec("mean_rps", "rps", "r", format_int_half_up),
            ColumnSpec("mean_latency_ms", "mean lat (ms)", "r", format_ms_1dp),
        ),
    ),
)


def table_placeholder(source_name: str, reason: str) -> str:
    safe_reason = latex_escape(reason)
    return (
        "% Auto-generated by scripts/csv_to_latex_tables.py\n"
        f"% Source: {source_name}\n"
        "\\begingroup\n"
        "\\scriptsize\n"
        "\\setlength{\\tabcolsep}{4pt}\n"
        "\\renewcommand{\\arraystretch}{1.05}\n"
        "\\begin{tabular}{l}\n"
        "\\hline\n"
        "status \\\\\n"
        "\\hline\n"
        f"{safe_reason} \\\\\n"
        "\\hline\n"
        "\\end{tabular}\n"
        "\\endgroup\n"
    )


def render_table(source_name: str, rows: list[dict[str, str]], columns: tuple[ColumnSpec, ...]) -> str:
    col_align = "".join(col.align for col in columns)
    header_cells = " & ".join(latex_escape(col.header) for col in columns)

    lines = [
        "% Auto-generated by scripts/csv_to_latex_tables.py",
        f"% Source: {source_name}",
        "\\begingroup",
        "\\scriptsize",
        "\\setlength{\\tabcolsep}{4pt}",
        "\\renewcommand{\\arraystretch}{1.05}",
        f"\\begin{{tabular}}{{{col_align}}}",
        "\\hline",
        f"{header_cells} \\\\",
        "\\hline",
    ]

    for row in rows:
        cells = []
        for col in columns:
            raw_value = row.get(col.key, "")
            cells.append(col.formatter(raw_value))
        lines.append(" & ".join(cells) + r" \\")

    lines += [
        "\\hline",
        "\\end{tabular}",
        "\\endgroup",
        "",
    ]
    return "\n".join(lines)


def load_csv_rows(path: Path) -> list[dict[str, str]]:
    with path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        return [dict(row) for row in reader]


def generate_one(summary_dir: Path, spec: TableSpec, strict_missing: bool) -> bool:
    csv_path = summary_dir / spec.csv_name
    tex_path = summary_dir / spec.tex_name
    tex_path.parent.mkdir(parents=True, exist_ok=True)

    if not csv_path.exists():
        msg = f"missing file: {spec.csv_name}"
        if strict_missing:
            log(f"[error] {msg}")
            return False
        tex_path.write_text(table_placeholder(spec.csv_name, msg), encoding="utf-8")
        log(f"[warn] {msg}")
        log(f"[write] {tex_path}")
        return True

    rows = load_csv_rows(csv_path)
    if not rows:
        tex_path.write_text(table_placeholder(spec.csv_name, "no rows"), encoding="utf-8")
        log(f"[warn] no rows in {csv_path}")
        log(f"[write] {tex_path}")
        return True

    rendered = render_table(spec.csv_name, rows, spec.columns)
    tex_path.write_text(rendered, encoding="utf-8")
    log(f"[write] {tex_path}")
    return True


def parse_args() -> argparse.Namespace:
    root = Path(__file__).resolve().parent.parent
    default_summary_dir = root / "results" / "summary"

    parser = argparse.ArgumentParser(description="Generate compact LaTeX tabular snippets from summary CSVs.")
    parser.add_argument(
        "--summary-dir",
        default=str(default_summary_dir),
        help="Directory containing summary CSVs and where .tex snippets will be written.",
    )
    parser.add_argument(
        "--strict-missing",
        action="store_true",
        help="Fail if any expected CSV file is missing instead of writing a placeholder table.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    summary_dir = Path(args.summary_dir).resolve()
    os.makedirs(summary_dir, exist_ok=True)
    log(f"[summary_dir] {summary_dir}")

    ok = True
    for spec in TABLES:
        ok = generate_one(summary_dir, spec, strict_missing=args.strict_missing) and ok

    return 0 if ok else 1


if __name__ == "__main__":
    raise SystemExit(main())
